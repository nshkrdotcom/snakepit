It is not a pipe dream, but achieving "Zero Config" where everything "Just Works" without custom Python code forces you to change your architecture from a simple **RPC (Remote Procedure Call)** system to a **Remote Object Management** system.

To achieve what you want—where you can compose `standard_transformations + implicit_multiplication` entirely from Elixir without writing a single line of Python glue code—you must treat Python objects as "Resources" that Elixir holds a handle to.

This is how bridges like `PyCall.jl` (Julia) and `reticulate` (R) work. They don't just "call functions"; they mirror the Python object lifecycle.

Here is the architecture you need to implement in `snakebridge` to make this a reality.

### The Solution: The "Object Handle" Protocol

Instead of serializing data, your bridge acts as a puppet master. If a Python function returns something complex (like a module, a function, or a class instance), you do not try to serialize it. You store it in a Python-side dictionary and give Elixir a "Handle" (an ID).

#### 1. The Protocol (Conceptual)

**Python Side (The Registry):**
You need a global dictionary in your Python runner that maps unique IDs to live objects.

```python
# Pseudo-code inside your python worker
registry = {}

def call_function(func_name, args):
    # 1. Resolve Args: If an arg is a Handle, look it up.
    real_args = [registry[arg.id] if isinstance(arg, Handle) else arg for arg in args]
    
    # 2. Execute
    result = func(*real_args)
    
    # 3. Return: If result is simple (int/str), return it.
    #    If it's complex (object/func), STORE it and return a Handle.
    if is_complex(result):
        obj_id = uuid.uuid4()
        registry[obj_id] = result
        return {"__type__": "ref", "id": obj_id}
    return result

```

**Elixir Side (The Puppet):**
You create a struct, say `%SnakeBridge.Ref{}`, that holds that ID. You implement the `SnakeBridge` client to automatically detect when it receives a Ref.

#### 2. How this solves the SymPy Problem (Step-by-Step)

If you implement this Generic Handle system, you can write this Elixir code without *any* custom Python wrappers:

```elixir
# 1. Get a handle to the standard transformations tuple
# Returns: %SnakeBridge.Ref{id: "ref_123"} pointing to the tuple in Python memory
standard = SnakeBridge.get_attr("sympy.parsing.sympy_parser", "standard_transformations")

# 2. Get a handle to the implicit multiplication function
# Returns: %SnakeBridge.Ref{id: "ref_456"}
implicit = SnakeBridge.get_attr("sympy.parsing.sympy_parser", "implicit_multiplication_application")

# 3. Create the tuple (Generic python tuple creation from Elixir)
# Returns: %SnakeBridge.Ref{id: "ref_789"}
tuple_arg = SnakeBridge.call_builtin("tuple", [[implicit]]) 

# 4. Add them together (Python tuples support +)
# Returns: %SnakeBridge.Ref{id: "ref_999"}
transforms = SnakeBridge.call_method(standard, "__add__", [tuple_arg])

# 5. Finally, call the function using the Handle
SnakeBridge.call("sympy", "parse_expr", ["2x"], kwargs: %{transformations: transforms})

```

**Result:** You successfully called a complex API with zero Python "glue" code. You composed the arguments dynamically from Elixir.

### The "Hidden Costs" of Zero Config

This is the only way to be truly generic. However, you must accept three trade-offs:

**1. Garbage Collection (The Hardest Part)**

* **The Problem:** In the example above, you created 4 intermediate objects in Python (ref_123, ref_456, etc.). Python keeps them alive forever because they are in the `registry`.
* **The Fix:** You must implement a "Release" mechanism.
* *Manual:* `SnakeBridge.release(ref)`
* *Automatic:* Use Elixir's functionality (like `__struct__` with a finalizer or linking it to a GenServer) to send a "delete" message to Python when the Elixir reference goes out of scope.



**2. Network Chattiness**

* **The Problem:** "Zero Config" means logic happens in Elixir, but execution happens in Python. A simple operation like `(a + b)` becomes a network round-trip.
* **The Mitigation:** This is acceptable for "configuration" steps (like setting up the parser) but bad for tight loops (processing a million rows).

**3. Reference Counting Drifts**

* If the Elixir process crashes, the Python side might still hold the objects in memory. You need a strategy to "flush" the registry if the Elixir connection dies.

### How to Ergonomically Wrap This (Compile Time)

Since you said you are building this at **compile time**, you can auto-generate modules that hide the ugliness of handles.

If you introspect `sympy`, your generator can create:

```elixir
defmodule SymPy.Parsing.SympyParser do
  # Generated function
  def standard_transformations() do
    SnakeBridge.get_attr("sympy.parsing.sympy_parser", "standard_transformations")
  end
  
  # Generated function
  def implicit_multiplication_application() do
    SnakeBridge.get_attr("sympy.parsing.sympy_parser", "implicit_multiplication_application")
  end
end

```

This makes the user code look cleaner:

```elixir
alias SymPy.Parsing.SympyParser, as: SP

transforms = SP.standard_transformations() 
             |> SnakeBridge.add(SP.implicit_multiplication_application())

SymPy.parse_expr("2x", transformations: transforms)

```

### Summary: Is it a pipe dream?

**No.** It is a standard pattern called **"Foreign Object Handles."**

* **To do it right:** You must stop thinking of the bridge as "passing data" and start thinking of it as "managing remote pointers."
* **The "One-Off" Killer:** Once you implement `get_attr`, `call_method`, and `release_ref` generically, you never have to write a specific SymPy/Pandas/NumPy wrapper again. They all just become object manipulations.

**Would you like me to sketch out the `registry` logic for the Python side of `snakebridge`?** That is the kernel that makes this entire generic system possible.
