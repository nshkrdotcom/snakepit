# v0.7.0: Python Environment Management - Implementation Plan

**Status:** Implementation Phase
**Version:** 0.7.0
**Date:** 2025-10-11
**Estimated Effort:** 3-4 weeks
**Complexity:** Medium

---

## Overview

This document provides a detailed, phase-by-phase implementation plan for v0.7.0 Python Environment Management. The implementation follows the proven v0.6.0 pattern: **foundation → core implementations → integration → polish**.

---

## Implementation Strategy

### Principles

1. **Zero Breaking Changes** - All existing v0.6.0 configs continue to work
2. **Incremental Value** - Each phase delivers working functionality
3. **Test-Driven** - Write tests before implementations
4. **Documentation-First** - Document as you code

### Phase Overview

```
Phase 1: Foundation (3-4 days)
  └─> Behavior + Resolver + System Environment

Phase 2: Core Environments (4-5 days)
  └─> UV, Venv, Docker implementations

Phase 3: Integration (3-4 days)
  └─> GRPCWorker, Config, Auto-detection

Phase 4: Additional Environments (3-4 days)
  └─> Pyenv, Poetry, Conda

Phase 5: Polish & Documentation (3-4 days)
  └─> Mix tasks, docs, examples
```

---

## Phase 1: Foundation (3-4 days)

### Goals

- Establish the `PythonEnvironment` behavior
- Implement resolver orchestration
- Implement System environment (backward compat)
- Implement detector foundation

### Tasks

#### Task 1.1: Create Behavior Module (4 hours)

**File:** `lib/snakepit/python_environment.ex`

```elixir
defmodule Snakepit.PythonEnvironment do
  @moduledoc """
  Behavior for Python environment resolution.
  ... (full docstring from architecture doc)
  """

  @type config :: map()
  @type env_config :: %{
    command: String.t(),
    args: [String.t()],
    env: [{String.t(), String.t()}],
    cwd: String.t() | nil,
    metadata: map()
  }

  @callback resolve_executable(config) ::
    {:ok, String.t()} | {:error, term()}

  @callback resolve_environment(config) ::
    {:ok, env_config()} | {:error, term()}

  @callback validate_environment(config) ::
    :ok | {:error, term(), details :: term()}

  @callback get_metadata(config) ::
    {:ok, map()} | {:error, term()}

  @optional_callbacks [get_metadata: 1]
end
```

**Tests:** `test/snakepit/python_environment_test.exs`

```elixir
defmodule Snakepit.PythonEnvironmentTest do
  use ExUnit.Case

  # Test that behavior is defined correctly
  test "behavior defines required callbacks" do
    assert Code.ensure_loaded?(Snakepit.PythonEnvironment)
    assert function_exported?(Snakepit.PythonEnvironment, :behaviour_info, 1)
  end
end
```

**Acceptance Criteria:**
- [ ] Behavior module compiles
- [ ] All callbacks defined with correct specs
- [ ] Documentation complete
- [ ] Tests pass

---

#### Task 1.2: Implement Resolver (6 hours)

**File:** `lib/snakepit/python_environment/resolver.ex`

```elixir
defmodule Snakepit.PythonEnvironment.Resolver do
  @moduledoc """
  Orchestrates Python environment resolution.
  ... (full implementation from architecture doc)
  """

  alias Snakepit.PythonEnvironment
  require Logger

  def resolve(pool_config) do
    # Implementation from architecture doc
  end

  defp auto_resolve(config) do
    # Implementation from architecture doc
  end

  defp resolve_with(module, config) do
    # Implementation from architecture doc
  end

  defp get_module(env_type) do
    # Implementation from architecture doc
  end
end
```

**Tests:** `test/snakepit/python_environment/resolver_test.exs`

```elixir
defmodule Snakepit.PythonEnvironment.ResolverTest do
  use ExUnit.Case
  alias Snakepit.PythonEnvironment.Resolver

  describe "resolve/1" do
    test "resolves :system environment" do
      config = %{python_environment: :system}
      assert {:ok, env_config} = Resolver.resolve(config)
      assert env_config.metadata.environment_type == :system
    end

    test "returns error for invalid environment type" do
      config = %{python_environment: :invalid}
      assert {:error, {:invalid_python_environment, :invalid}} =
        Resolver.resolve(config)
    end

    test "uses auto-detection when :auto specified" do
      config = %{python_environment: :auto}
      assert {:ok, env_config} = Resolver.resolve(config)
      # Should detect or fallback to system
      assert env_config.metadata.environment_type in [:system, :uv, :venv]
    end
  end
end
```

**Acceptance Criteria:**
- [ ] Resolver resolves all environment types
- [ ] Auto-detection fallback works
- [ ] Error handling complete
- [ ] All tests pass

---

#### Task 1.3: Implement System Environment (6 hours)

**File:** `lib/snakepit/python_environment/system.ex`

```elixir
defmodule Snakepit.PythonEnvironment.System do
  @behaviour Snakepit.PythonEnvironment
  @moduledoc """
  System Python environment (default, v0.6.0 compatible).
  ... (full implementation from architecture doc)
  """

  @impl true
  def resolve_executable(config) do
    # Implementation from architecture doc
  end

  @impl true
  def resolve_environment(config) do
    # Implementation from architecture doc
  end

  @impl true
  def validate_environment(config) do
    # Implementation from architecture doc
  end

  @impl true
  def get_metadata(config) do
    # Implementation from architecture doc
  end

  # Private helpers
  defp get_python_version(python) do
    # Implementation from architecture doc
  end

  defp check_gil_status(python) do
    # Implementation from architecture doc
  end
end
```

**Tests:** `test/snakepit/python_environment/system_test.exs`

```elixir
defmodule Snakepit.PythonEnvironment.SystemTest do
  use ExUnit.Case
  alias Snakepit.PythonEnvironment.System

  describe "resolve_executable/1" do
    test "finds system python" do
      assert {:ok, path} = System.resolve_executable(%{})
      assert is_binary(path)
      assert String.contains?(path, "python")
    end

    test "respects explicit python_executable config" do
      python = System.find_executable("python3")
      config = %{python_executable: python}
      assert {:ok, ^python} = System.resolve_executable(config)
    end

    test "respects SNAKEPIT_PYTHON env var" do
      python = System.find_executable("python3")
      System.put_env("SNAKEPIT_PYTHON", python)

      assert {:ok, ^python} = System.resolve_executable(%{})

      System.delete_env("SNAKEPIT_PYTHON")
    end
  end

  describe "resolve_environment/1" do
    test "returns valid environment config" do
      {:ok, env} = System.resolve_environment(%{})

      assert env.command
      assert env.args == []
      assert env.env == []
      assert env.cwd == nil
      assert env.metadata.environment_type == :system
    end
  end

  describe "validate_environment/1" do
    test "validates existing python" do
      assert :ok = System.validate_environment(%{})
    end

    test "errors on missing python" do
      config = %{python_executable: "/nonexistent/python"}
      assert {:error, :python_not_found, _} =
        System.validate_environment(config)
    end
  end

  describe "get_metadata/1" do
    test "returns metadata with version" do
      {:ok, meta} = System.get_metadata(%{})

      assert meta.python_path
      assert meta.python_version
      assert meta.environment_type == :system
      assert is_boolean(meta.free_threading_enabled)
    end
  end
end
```

**Acceptance Criteria:**
- [ ] All callbacks implemented
- [ ] Backward compatible with v0.6.0 behavior
- [ ] GIL status detection works
- [ ] All tests pass (4 test groups)

---

#### Task 1.4: Implement Detector Foundation (4 hours)

**File:** `lib/snakepit/python_environment/detector.ex`

```elixir
defmodule Snakepit.PythonEnvironment.Detector do
  @moduledoc """
  Automatically detects Python environment type.
  ... (full implementation from architecture doc)
  """

  require Logger

  def detect(base_dir \\ File.cwd!()) do
    # Implementation from architecture doc
    # Initially just detect UV, Venv, System
    # Will expand in Phase 4
  end
end
```

**Tests:** `test/snakepit/python_environment/detector_test.exs`

```elixir
defmodule Snakepit.PythonEnvironment.DetectorTest do
  use ExUnit.Case
  alias Snakepit.PythonEnvironment.Detector

  setup do
    # Create temp test directory
    tmp_dir = Path.join(System.tmp_dir!(), "snakepit_detector_test_#{:rand.uniform(10000)}")
    File.mkdir_p!(tmp_dir)

    on_exit(fn -> File.rm_rf!(tmp_dir) end)

    {:ok, tmp_dir: tmp_dir}
  end

  describe "detect/1" do
    test "detects UV environment", %{tmp_dir: tmp_dir} do
      File.write!(Path.join(tmp_dir, "uv.lock"), "")

      assert {:ok, :uv, config} = Detector.detect(tmp_dir)
      assert config.project_dir == tmp_dir
    end

    test "detects Venv environment (.venv)", %{tmp_dir: tmp_dir} do
      File.mkdir_p!(Path.join(tmp_dir, ".venv"))

      assert {:ok, :venv, config} = Detector.detect(tmp_dir)
      assert config.venv_path == ".venv"
    end

    test "detects Venv environment (venv)", %{tmp_dir: tmp_dir} do
      File.mkdir_p!(Path.join(tmp_dir, "venv"))

      assert {:ok, :venv, config} = Detector.detect(tmp_dir)
      assert config.venv_path == "venv"
    end

    test "falls back to system when no environment detected", %{tmp_dir: tmp_dir} do
      assert {:ok, :system, config} = Detector.detect(tmp_dir)
      assert config == %{}
    end
  end
end
```

**Acceptance Criteria:**
- [ ] Detects UV, Venv, System
- [ ] Returns appropriate config for each
- [ ] All tests pass

---

### Phase 1 Deliverables

- [ ] `Snakepit.PythonEnvironment` behavior defined
- [ ] `Snakepit.PythonEnvironment.Resolver` working
- [ ] `Snakepit.PythonEnvironment.System` complete
- [ ] `Snakepit.PythonEnvironment.Detector` foundation
- [ ] 15+ tests passing
- [ ] Documentation complete

**Time Check:** 3-4 days ✅

---

## Phase 2: Core Environments (4-5 days)

### Goals

- Implement UV environment (modern standard)
- Implement Venv environment (traditional)
- Implement Docker environment (production)
- Full test coverage

### Tasks

#### Task 2.1: Implement UV Environment (8 hours)

**File:** `lib/snakepit/python_environment/uv.ex`

```elixir
defmodule Snakepit.PythonEnvironment.UV do
  @behaviour Snakepit.PythonEnvironment
  @moduledoc """
  UV Python environment manager.
  ... (full implementation from architecture doc)
  """

  # Full implementation from architecture doc
end
```

**Tests:** `test/snakepit/python_environment/uv_test.exs`

```elixir
defmodule Snakepit.PythonEnvironment.UVTest do
  use ExUnit.Case
  alias Snakepit.PythonEnvironment.UV

  setup do
    tmp_dir = create_tmp_uv_project()
    on_exit(fn -> File.rm_rf!(tmp_dir) end)
    {:ok, tmp_dir: tmp_dir}
  end

  describe "resolve_executable/1" do
    test "finds uv command" do
      case System.find_executable("uv") do
        nil -> assert {:error, :uv_not_found} = UV.resolve_executable(%{})
        path -> assert {:ok, ^path} = UV.resolve_executable(%{})
      end
    end
  end

  describe "resolve_environment/1" do
    test "returns correct command structure", %{tmp_dir: tmp_dir} do
      config = %{project_dir: tmp_dir}
      {:ok, env} = UV.resolve_environment(config)

      assert env.command == System.find_executable("uv")
      assert env.args == ["run", "python"]
      assert {"UV_PROJECT_ENVIRONMENT", "production"} in env.env
      assert env.cwd == tmp_dir
    end

    test "respects python_version config", %{tmp_dir: tmp_dir} do
      config = %{project_dir: tmp_dir, python_version: "3.13"}
      {:ok, env} = UV.resolve_environment(config)

      assert ["--python", "3.13", "run", "python"] = env.args
    end
  end

  describe "validate_environment/1" do
    test "validates UV project", %{tmp_dir: tmp_dir} do
      if System.find_executable("uv") do
        config = %{project_dir: tmp_dir}
        assert :ok = UV.validate_environment(config)
      end
    end

    test "errors on missing uv.lock" do
      config = %{project_dir: "/tmp/no_uv"}
      assert {:error, :uv_lock_not_found, _} =
        UV.validate_environment(config)
    end

    test "errors when uv not installed", %{tmp_dir: tmp_dir} do
      # Mock System.find_executable to return nil
      # Or skip if uv is installed
      if is_nil(System.find_executable("uv")) do
        config = %{project_dir: tmp_dir}
        assert {:error, :uv_not_installed, nil} =
          UV.validate_environment(config)
      end
    end
  end

  describe "get_metadata/1" do
    @tag :requires_uv
    test "collects UV metadata", %{tmp_dir: tmp_dir} do
      config = %{project_dir: tmp_dir}
      {:ok, meta} = UV.get_metadata(config)

      assert meta.environment_type == :uv
      assert meta.project_dir == tmp_dir
      assert meta.python_version
      assert is_boolean(meta.free_threading_enabled)
    end
  end

  defp create_tmp_uv_project do
    tmp = Path.join(System.tmp_dir!(), "uv_test_#{:rand.uniform(10000)}")
    File.mkdir_p!(tmp)
    File.write!(Path.join(tmp, "uv.lock"), "")
    tmp
  end
end
```

**Acceptance Criteria:**
- [ ] All UV callbacks implemented
- [ ] Python version selection works
- [ ] UV environment variable handling
- [ ] 4 test groups passing

---

#### Task 2.2: Implement Venv Environment (6 hours)

**File:** `lib/snakepit/python_environment/venv.ex`

```elixir
defmodule Snakepit.PythonEnvironment.Venv do
  @behaviour Snakepit.PythonEnvironment
  @moduledoc """
  Standard Python virtualenv environment.
  ... (full implementation from architecture doc)
  """

  # Full implementation from architecture doc
end
```

**Tests:** `test/snakepit/python_environment/venv_test.exs`

```elixir
defmodule Snakepit.PythonEnvironment.VenvTest do
  use ExUnit.Case
  alias Snakepit.PythonEnvironment.Venv

  setup do
    tmp_dir = create_tmp_venv()
    on_exit(fn -> File.rm_rf!(tmp_dir) end)
    {:ok, tmp_dir: tmp_dir, venv_path: Path.join(tmp_dir, ".venv")}
  end

  describe "resolve_executable/1" do
    test "finds venv python", %{venv_path: venv_path} do
      config = %{venv_path: venv_path}
      {:ok, path} = Venv.resolve_executable(config)

      assert String.ends_with?(path, "/bin/python3")
      assert File.exists?(path)
    end

    test "errors on missing venv" do
      config = %{venv_path: "/nonexistent/.venv"}
      assert {:error, :venv_not_found} = Venv.resolve_executable(config)
    end
  end

  describe "validate_environment/1" do
    test "validates existing venv", %{venv_path: venv_path} do
      config = %{venv_path: venv_path}
      assert :ok = Venv.validate_environment(config)
    end

    test "errors on missing venv directory" do
      config = %{venv_path: "/tmp/missing_venv"}
      assert {:error, :venv_not_found, _} =
        Venv.validate_environment(config)
    end
  end

  defp create_tmp_venv do
    tmp = Path.join(System.tmp_dir!(), "venv_test_#{:rand.uniform(10000)}")
    File.mkdir_p!(tmp)

    # Create minimal venv structure
    venv = Path.join(tmp, ".venv")
    File.mkdir_p!(Path.join(venv, "bin"))

    # Create symlink to system python (if available)
    python = System.find_executable("python3")
    if python do
      File.ln_s!(python, Path.join([venv, "bin", "python3"]))
    end

    tmp
  end
end
```

**Acceptance Criteria:**
- [ ] Venv callbacks implemented
- [ ] Path resolution works (relative and absolute)
- [ ] Validation robust
- [ ] Tests pass

---

#### Task 2.3: Implement Docker Environment (8 hours)

**File:** `lib/snakepit/python_environment/docker.ex`

```elixir
defmodule Snakepit.PythonEnvironment.Docker do
  @behaviour Snakepit.PythonEnvironment
  @moduledoc """
  Docker containerized Python environment.
  ... (full implementation from architecture doc)
  """

  # Full implementation from architecture doc
end
```

**Tests:** `test/snakepit/python_environment/docker_test.exs`

```elixir
defmodule Snakepit.PythonEnvironment.DockerTest do
  use ExUnit.Case
  alias Snakepit.PythonEnvironment.Docker

  describe "resolve_executable/1" do
    test "finds docker command" do
      case System.find_executable("docker") do
        nil -> assert {:error, :docker_not_found} = Docker.resolve_executable(%{})
        path -> assert {:ok, ^path} = Docker.resolve_executable(%{})
      end
    end
  end

  describe "resolve_environment/1" do
    test "constructs correct docker exec command" do
      config = %{container_name: "test-container"}
      {:ok, env} = Docker.resolve_environment(config)

      assert env.command == System.find_executable("docker")
      assert env.args == ["exec", "-i", "test-container", "python3"]
    end

    test "respects custom python_path" do
      config = %{
        container_name: "test-container",
        python_path: "/usr/local/bin/python3.13"
      }
      {:ok, env} = Docker.resolve_environment(config)

      assert List.last(env.args) == "/usr/local/bin/python3.13"
    end
  end

  describe "validate_environment/1" do
    @tag :requires_docker
    test "validates running container" do
      # This test requires Docker and a running container
      # Skip if Docker not available or no test container
      if System.find_executable("docker") && test_container_running?() do
        config = %{container_name: "snakepit-test"}
        assert :ok = Docker.validate_environment(config)
      end
    end

    test "errors on non-running container" do
      config = %{container_name: "nonexistent-container"}
      assert {:error, :container_not_found, _} =
        Docker.validate_environment(config)
    end
  end

  defp test_container_running? do
    case System.cmd("docker", ["ps", "--filter", "name=snakepit-test",
                               "--format", "{{.Names}}"]) do
      {"snakepit-test\n", 0} -> true
      _ -> false
    end
  end
end
```

**Acceptance Criteria:**
- [ ] Docker exec command construction
- [ ] Container validation
- [ ] Custom python path support
- [ ] Tests pass (with/without Docker)

---

### Phase 2 Deliverables

- [ ] UV environment complete
- [ ] Venv environment complete
- [ ] Docker environment complete
- [ ] 12+ additional tests
- [ ] Integration with Resolver
- [ ] Documentation updated

**Time Check:** 4-5 days ✅

---

## Phase 3: Integration (3-4 days)

### Goals

- Integrate with `GRPCWorker`
- Integrate with `Config` module
- Update `GRPCPython` adapter
- Full backward compatibility

### Tasks

#### Task 3.1: Enhance Config Module (6 hours)

**File:** `lib/snakepit/config.ex` (modify existing)

**Changes:**

```elixir
# Add to normalize_pool_config/1
def normalize_pool_config(config) do
  # ... existing code ...

  base_config
  |> Map.put_new(:python_environment, :auto)  # NEW
  |> Map.put_new(:python_config, %{})         # NEW
end

# Add validation
defp validate_python_environment(config) do
  case Map.get(config, :python_environment, :auto) do
    :auto -> :ok
    env when env in [:system, :uv, :venv, :pyenv, :poetry, :conda, :docker] -> :ok
    module when is_atom(module) ->
      # Validate it's a module
      if Code.ensure_loaded?(module), do: :ok, else: {:error, :module_not_found}
    invalid ->
      {:error, {:invalid_python_environment, invalid}}
  end
end
```

**Tests:** `test/snakepit/config_test.exs` (extend existing)

```elixir
describe "python_environment configuration" do
  test "normalizes with default :auto" do
    config = normalize_pool_config(%{name: :test})
    assert config.python_environment == :auto
    assert config.python_config == %{}
  end

  test "accepts valid environment types" do
    for env <- [:auto, :system, :uv, :venv, :docker] do
      config = %{name: :test, python_environment: env}
      assert {:ok, _} = validate_pool_config(config)
    end
  end

  test "accepts custom module" do
    config = %{name: :test, python_environment: MyApp.CustomEnv}
    # Should validate if module exists
    assert {:ok, _} = validate_pool_config(config)
  end

  test "rejects invalid environment type" do
    config = %{name: :test, python_environment: :invalid}
    assert {:error, {:invalid_python_environment, :invalid}} =
      validate_pool_config(config)
  end
end
```

**Acceptance Criteria:**
- [ ] Config validates python_environment
- [ ] Defaults work correctly
- [ ] Tests pass

---

#### Task 3.2: Integrate with GRPCWorker (8 hours)

**File:** `lib/snakepit/grpc_worker.ex` (modify existing)

**Changes:**

```elixir
@impl true
def init(opts) do
  # ... existing setup ...

  adapter = Keyword.fetch!(opts, :adapter)
  pool_config = Keyword.get(opts, :pool_config, %{})

  # NEW: Resolve Python environment
  case Snakepit.PythonEnvironment.Resolver.resolve(pool_config) do
    {:ok, env_config} ->
      # Use resolved environment configuration
      executable = env_config.command
      script = adapter.script_path()

      # Merge environment args with script args
      script_args = adapter.script_args() || []
      args = case env_config.args do
        [] -> [script | script_args]
        env_args -> env_args ++ [script | script_args]
      end

      # Build port options with environment
      port_opts = [
        :binary,
        :exit_status,
        :use_stdio,
        :stderr_to_stdout,
        {:args, args},
        {:cd, env_config.cwd || Path.dirname(script)},
        {:env, build_env_list(env_config.env)}  # NEW
      ]

      Logger.info("Starting Python with environment: #{env_config.metadata.environment_type}")
      Logger.debug("Command: #{executable}")
      Logger.debug("Args: #{inspect(args)}")

      server_port = Port.open({:spawn_executable, executable}, port_opts)
      # ... rest of initialization ...

    {:error, reason} ->
      Logger.error("Failed to resolve Python environment: #{inspect(reason)}")
      {:stop, {:python_environment_error, reason}}
  end
end

# NEW: Convert environment map to list format for Port
defp build_env_list(env_map) when is_map(env_map) do
  Enum.map(env_map, fn {k, v} -> {to_charlist(k), to_charlist(v)} end)
end

defp build_env_list(env_list) when is_list(env_list) do
  Enum.map(env_list, fn
    {k, v} when is_binary(k) and is_binary(v) ->
      {to_charlist(k), to_charlist(v)}
    {k, v} -> {k, v}
  end)
end
```

**Tests:** `test/snakepit/grpc_worker_test.exs` (extend existing)

```elixir
describe "Python environment integration" do
  test "uses resolved environment" do
    opts = [
      id: "test_worker",
      adapter: Snakepit.Adapters.GRPCPython,
      pool_config: %{
        python_environment: :system
      }
    ]

    # Worker should start successfully
    {:ok, worker} = GRPCWorker.start_link(opts)
    # ... verify it's using system python ...
  end

  test "fails on invalid environment" do
    opts = [
      id: "test_worker",
      adapter: Snakepit.Adapters.GRPCPython,
      pool_config: %{
        python_environment: :invalid
      }
    ]

    # Should fail during init
    assert {:error, {:python_environment_error, _}} =
      GRPCWorker.start_link(opts)
  end
end
```

**Acceptance Criteria:**
- [ ] GRPCWorker uses Resolver
- [ ] Environment config applied correctly
- [ ] Error handling robust
- [ ] Tests pass

---

#### Task 3.3: Update GRPCPython Adapter (4 hours)

**File:** `lib/snakepit/adapters/grpc_python.ex` (modify existing)

**Changes:**

```elixir
@impl true
def executable_path do
  # DEPRECATED in v0.7.0 but kept for backward compatibility
  # This will be overridden by PythonEnvironment.Resolver
  Logger.warning("""
  GRPCPython.executable_path/0 is deprecated in v0.7.0.
  Configure python_environment in pool config instead.
  """)

  Application.get_env(:snakepit, :python_executable) ||
    System.get_env("SNAKEPIT_PYTHON") ||
    System.find_executable("python3") ||
    System.find_executable("python")
end
```

**Tests:** Update existing tests to verify backward compatibility

**Acceptance Criteria:**
- [ ] Backward compatibility maintained
- [ ] Deprecation warning added
- [ ] Tests still pass

---

### Phase 3 Deliverables

- [ ] GRPCWorker integrated
- [ ] Config module enhanced
- [ ] GRPCPython adapter updated
- [ ] Full backward compatibility verified
- [ ] 10+ integration tests

**Time Check:** 3-4 days ✅

---

## Phase 4: Additional Environments (3-4 days)

### Goals

- Implement Pyenv environment
- Implement Poetry environment
- Implement Conda environment
- Complete detector

### Tasks

#### Task 4.1: Implement Pyenv Environment (6 hours)

**File:** `lib/snakepit/python_environment/pyenv.ex`

```elixir
defmodule Snakepit.PythonEnvironment.Pyenv do
  @behaviour Snakepit.PythonEnvironment
  @moduledoc """
  Pyenv Python version manager environment.

  ## Configuration

      %{
        python_environment: :pyenv,
        python_config: %{
          python_version: "3.13.0"  # Required
        }
      }
  """

  @impl true
  def resolve_executable(config) do
    version = Map.fetch!(config, :python_version)
    pyenv_root = System.get_env("PYENV_ROOT") ||
                 Path.expand("~/.pyenv")

    python_path = Path.join([pyenv_root, "versions", version, "bin", "python3"])

    if File.exists?(python_path) do
      {:ok, python_path}
    else
      {:error, :pyenv_version_not_found}
    end
  end

  @impl true
  def resolve_environment(config) do
    with {:ok, python} <- resolve_executable(config) do
      {:ok, %{
        command: python,
        args: [],
        env: [],
        cwd: nil,
        metadata: %{
          environment_type: :pyenv,
          python_version: Map.get(config, :python_version)
        }
      }}
    end
  end

  @impl true
  def validate_environment(config) do
    version = Map.get(config, :python_version)

    if version do
      case resolve_executable(config) do
        {:ok, _} -> :ok
        {:error, reason} -> {:error, reason, version}
      end
    else
      {:error, :python_version_required, nil}
    end
  end
end
```

**Tests:** Similar pattern to UV/Venv tests

**Acceptance Criteria:**
- [ ] Pyenv version selection works
- [ ] PYENV_ROOT handling correct
- [ ] Tests pass

---

#### Task 4.2: Implement Poetry Environment (6 hours)

**File:** `lib/snakepit/python_environment/poetry.ex`

Similar to UV but using `poetry run python`

**Acceptance Criteria:**
- [ ] Poetry environment implemented
- [ ] poetry.lock detection
- [ ] Tests pass

---

#### Task 4.3: Implement Conda Environment (6 hours)

**File:** `lib/snakepit/python_environment/conda.ex`

Conda environment activation handling

**Acceptance Criteria:**
- [ ] Conda environment implemented
- [ ] Environment activation works
- [ ] Tests pass

---

#### Task 4.4: Complete Detector (4 hours)

**File:** `lib/snakepit/python_environment/detector.ex` (extend)

Add detection for Poetry, Pyenv, Conda

**Acceptance Criteria:**
- [ ] All environments detected
- [ ] Priority order correct
- [ ] Tests comprehensive

---

### Phase 4 Deliverables

- [ ] Pyenv environment complete
- [ ] Poetry environment complete
- [ ] Conda environment complete
- [ ] Detector complete
- [ ] 15+ additional tests

**Time Check:** 3-4 days ✅

---

## Phase 5: Polish & Documentation (3-4 days)

### Goals

- Implement Mix tasks
- Complete documentation
- Create examples
- Final testing

### Tasks

#### Task 5.1: Implement `mix snakepit.check_python` (8 hours)

**File:** `lib/mix/tasks/snakepit.check_python.ex`

Full implementation from architecture doc

**Tests:** `test/mix/tasks/snakepit.check_python_test.exs`

**Acceptance Criteria:**
- [ ] Task validates all pools
- [ ] Output clear and helpful
- [ ] Suggestions useful
- [ ] Tests pass

---

#### Task 5.2: Update Documentation (8 hours)

**Files to update:**

1. `README.md` - Add v0.7.0 section
2. `docs/migration_v0.6_to_v0.7.md` - New migration guide
3. `docs/guides/python_environments.md` - New comprehensive guide
4. Update `CHANGELOG.md`

**Content:**

```markdown
## Python Environments Guide

### Quick Start

Auto-detection (recommended):
```elixir
config :snakepit,
  pools: [
    %{name: :default, python_environment: :auto}
  ]
```

### Environment Types

- System Python
- UV (Modern package manager)
- Venv (Traditional virtualenv)
- ... (full guide)

### Production Deployment

Docker best practices...

### Troubleshooting

Common issues and fixes...
```

**Acceptance Criteria:**
- [ ] README updated
- [ ] Migration guide complete
- [ ] Environment guide comprehensive
- [ ] CHANGELOG updated

---

#### Task 5.3: Create Examples (6 hours)

**Files to create:**

1. `examples/python_env_auto.exs` - Auto-detection demo
2. `examples/python_env_uv.exs` - UV environment demo
3. `examples/python_env_docker.exs` - Docker demo
4. `examples/python_env_multi.exs` - Multi-environment setup

**Example:**

```elixir
# examples/python_env_auto.exs
# Demonstrates auto-detection of Python environment

Mix.install([
  {:snakepit, path: ".."}
])

# Auto-detect environment
config = %{
  name: :demo,
  python_environment: :auto
}

IO.puts("Starting Snakepit with auto-detected environment...")

{:ok, _} = Snakepit.start_link(pools: [config])

# Execute a command
{:ok, result} = Snakepit.execute("ping", %{})
IO.inspect(result, label: "Result")

IO.puts("\nEnvironment info:")
{:ok, env_info} = Snakepit.execute("get_stats", %{})
IO.inspect(env_info, label: "Environment")
```

**Acceptance Criteria:**
- [ ] 4 example scripts created
- [ ] All examples work
- [ ] Well-commented
- [ ] README references examples

---

#### Task 5.4: Integration Testing (6 hours)

**Create end-to-end tests:**

```elixir
defmodule Snakepit.PythonEnvironmentE2ETest do
  use ExUnit.Case

  @moduletag :integration

  test "full workflow: auto-detection → validation → worker start → execution" do
    # 1. Auto-detect environment
    # 2. Validate configuration
    # 3. Start worker pool
    # 4. Execute commands
    # 5. Verify correct environment used
  end

  test "multi-pool with different environments" do
    # Start pools with different environments
    # Verify each uses correct Python
  end
end
```

**Acceptance Criteria:**
- [ ] E2E tests comprehensive
- [ ] Cover all major workflows
- [ ] Tests pass

---

### Phase 5 Deliverables

- [ ] Mix task complete and documented
- [ ] All documentation updated
- [ ] 4 working examples
- [ ] E2E tests passing
- [ ] Release notes drafted

**Time Check:** 3-4 days ✅

---

## Testing Strategy

### Test Pyramid

```
    E2E Tests (5)
        ↑
  Integration Tests (25)
        ↑
    Unit Tests (50+)
```

### Test Coverage Goals

- **Unit tests:** >90% coverage
- **Integration tests:** All major workflows
- **E2E tests:** Complete user journeys

### Test Organization

```
test/
├── snakepit/
│   ├── python_environment_test.exs           # Behavior tests
│   ├── python_environment/
│   │   ├── resolver_test.exs                 # Resolver unit tests
│   │   ├── detector_test.exs                 # Detector unit tests
│   │   ├── system_test.exs                   # System env tests
│   │   ├── uv_test.exs                       # UV env tests
│   │   ├── venv_test.exs                     # Venv env tests
│   │   ├── docker_test.exs                   # Docker env tests
│   │   ├── pyenv_test.exs                    # Pyenv env tests
│   │   ├── poetry_test.exs                   # Poetry env tests
│   │   └── conda_test.exs                    # Conda env tests
│   ├── config_test.exs                       # Config integration
│   └── grpc_worker_test.exs                  # Worker integration
├── mix/
│   └── tasks/
│       └── snakepit.check_python_test.exs    # Mix task tests
└── integration/
    └── python_environment_e2e_test.exs       # End-to-end tests
```

---

## Risk Management

### Identified Risks

#### Risk 1: Environment Detection False Positives

**Mitigation:**
- Comprehensive validation before worker start
- Clear error messages
- `mix snakepit.check_python` for pre-flight

#### Risk 2: Backward Compatibility Breaking

**Mitigation:**
- Extensive v0.6.0 regression testing
- Keep `adapter.executable_path/0` working
- Default to `:auto` which includes `:system` fallback

#### Risk 3: Docker Container Not Running

**Mitigation:**
- Validation checks container status before worker start
- Clear error: "Container not running: start with `docker start <name>`"
- Health check after start

#### Risk 4: Complex Environment Edge Cases

**Mitigation:**
- Support custom environment modules
- Good error reporting
- Comprehensive docs

---

## Success Criteria

### Functional Requirements

- [ ] All 7 environments implemented (System, UV, Venv, Docker, Pyenv, Poetry, Conda)
- [ ] Auto-detection works for 6 environment types
- [ ] Full backward compatibility with v0.6.0
- [ ] `mix snakepit.check_python` validates all pools
- [ ] Clear error messages for all failure modes

### Non-Functional Requirements

- [ ] <2ms overhead for environment resolution
- [ ] Zero performance impact on request execution
- [ ] <5% memory overhead
- [ ] All tests pass (80+ tests)
- [ ] Documentation complete

### User Experience

- [ ] "Just works" for common setups (UV, Venv)
- [ ] Clear errors when environment missing
- [ ] Helpful suggestions (run `uv init`, `docker start`, etc.)
- [ ] Mix task shows environment status

---

## Release Checklist

### Code Complete

- [ ] All phases completed
- [ ] All tests passing
- [ ] No compiler warnings
- [ ] Dialyzer clean

### Documentation

- [ ] README updated
- [ ] Migration guide complete
- [ ] API docs complete
- [ ] Examples working
- [ ] CHANGELOG updated

### Quality Assurance

- [ ] Manual testing on Ubuntu
- [ ] Manual testing on macOS
- [ ] Manual testing on WSL
- [ ] Docker testing
- [ ] Backward compatibility verified

### Release

- [ ] Version bump to 0.7.0
- [ ] Git tag created
- [ ] Hex package published
- [ ] GitHub release created
- [ ] Announcement drafted

---

## Timeline Summary

| Phase | Duration | Deliverables |
|-------|----------|--------------|
| Phase 1: Foundation | 3-4 days | Behavior, Resolver, System, Detector base |
| Phase 2: Core Environments | 4-5 days | UV, Venv, Docker |
| Phase 3: Integration | 3-4 days | GRPCWorker, Config, Adapter updates |
| Phase 4: Additional Environments | 3-4 days | Pyenv, Poetry, Conda, Complete detector |
| Phase 5: Polish & Docs | 3-4 days | Mix task, docs, examples, E2E tests |
| **Total** | **16-21 days** | **Complete v0.7.0** |

**Estimated:** 3-4 weeks with 1 developer
**Conservative:** 4-5 weeks accounting for unknowns

---

## Post-Release

### v0.7.1 Improvements

Gather feedback and address:
- Additional environment types
- Enhanced auto-detection
- Performance optimizations
- Documentation improvements

### v0.7.2+ Maintenance

- Bug fixes
- Community contributions
- Environment updates (e.g., new UV features)

---

## Appendix: File Structure

```
lib/snakepit/
├── python_environment.ex                     # Behavior definition
├── python_environment/
│   ├── resolver.ex                           # Orchestrator
│   ├── detector.ex                           # Auto-detection
│   ├── validator.ex                          # Compatibility checks
│   ├── system.ex                             # System Python
│   ├── uv.ex                                 # UV environment
│   ├── venv.ex                               # Venv environment
│   ├── docker.ex                             # Docker environment
│   ├── pyenv.ex                              # Pyenv environment
│   ├── poetry.ex                             # Poetry environment
│   └── conda.ex                              # Conda environment
├── config.ex                                 # Enhanced config
├── grpc_worker.ex                            # Enhanced worker
└── adapters/
    └── grpc_python.ex                        # Updated adapter

lib/mix/tasks/
└── snakepit.check_python.ex                  # Validation mix task

test/snakepit/
└── python_environment/
    ├── ... (test files matching above)

docs/
├── guides/
│   └── python_environments.md                # Comprehensive guide
└── migration_v0.6_to_v0.7.md                 # Migration guide

examples/
├── python_env_auto.exs
├── python_env_uv.exs
├── python_env_docker.exs
└── python_env_multi.exs
```

Total New Files: ~20
Total Modified Files: ~5
Total New Tests: ~80
Total Lines of Code: ~3,500

---

## Next Steps

1. **Review and approve** this implementation plan
2. **Create GitHub project** with all tasks
3. **Begin Phase 1** implementation
4. **Daily standups** to track progress
5. **Weekly demos** of completed phases

---

**Document Status:** Ready for Implementation
**Last Updated:** 2025-10-11
**Approved By:** [Pending]
