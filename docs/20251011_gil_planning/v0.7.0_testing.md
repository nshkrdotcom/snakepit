# Snakepit v0.7.0 Python Environment Testing Strategy

**Feature**: Python Environment Abstraction Layer  
**Complexity**: High (8 environments × 3 profiles × 2 OS types = 48 test scenarios)  
**Risk**: Critical path - if Python doesn't start, nothing works  
**Date**: 2025-10-11

---

## Table of Contents

1. [Testing Pyramid](#testing-pyramid)
2. [Test Environments](#test-environments)
3. [Unit Tests](#unit-tests)
4. [Integration Tests](#integration-tests)
5. [End-to-End Tests](#end-to-end)
6. [CI/CD Strategy](#cicd-strategy)
7. [Local Testing](#local-testing)
8. [Troubleshooting](#troubleshooting)

---

## Testing Pyramid

```
         E2E Tests (10)
       ┌─────────────────┐
       │ Full integration│  Docker, production scenarios
       └─────────────────┘
              ▲
              │
     Integration Tests (30)
   ┌──────────────────────────┐
   │ Environment resolution   │  Mock filesystems, real Python
   │ Worker startup/shutdown  │
   └──────────────────────────┘
              ▲
              │
        Unit Tests (100+)
   ┌──────────────────────────────┐
   │ Path resolution              │  Pure functions, fast
   │ Config validation            │
   │ Error handling               │
   └──────────────────────────────┘
```

**Target Breakdown**:
- Unit: 100+ tests, <1s total runtime
- Integration: 30 tests, <30s total runtime
- E2E: 10 tests, <2m total runtime

**Total**: ~140 tests, <3.5 minutes full suite

---

## Test Environments

### Priority Matrix

| Environment | Priority | Complexity | Test Coverage |
|-------------|----------|------------|---------------|
| System      | P0       | Low        | 100%          |
| Venv        | P0       | Low        | 100%          |
| UV          | P0       | Medium     | 100%          |
| Docker      | P1       | High       | 80%           |
| Pyenv       | P1       | Medium     | 80%           |
| Poetry      | P2       | Medium     | 60%           |
| Conda       | P2       | High       | 40%           |
| Custom      | P3       | N/A        | Examples only |

**Rationale**:
- **P0**: Must work in CI, common in production
- **P1**: Important but can verify manually
- **P2**: Nice-to-have, community tested
- **P3**: User responsibility

---

## Unit Tests

### Test File Structure

```
test/
├── python_environment/
│   ├── system_test.exs          # SystemPython behavior
│   ├── venv_test.exs             # Venv detection/resolution
│   ├── uv_test.exs               # UV project handling
│   ├── docker_test.exs           # Docker exec logic
│   ├── pyenv_test.exs            # Pyenv version resolution
│   ├── detector_test.exs         # Auto-detection logic
│   └── validator_test.exs        # Environment validation
├── fixtures/
│   ├── fake_venv/                # Mock .venv structure
│   ├── uv_project/               # Mock UV project
│   ├── pyenv_home/               # Mock pyenv structure
│   └── docker_mock/              # Mock Docker CLI responses
└── support/
    └── python_environment_case.exs  # Shared test helpers
```

### 1. SystemPython Tests (test/python_environment/system_test.exs)

```elixir
defmodule Snakepit.PythonEnvironment.SystemTest do
  use ExUnit.Case, async: true
  alias Snakepit.PythonEnvironment.System

  describe "resolve_python_executable/1" do
    test "returns python3 by default" do
      assert {:ok, "python3"} = System.resolve_python_executable(%{})
    end

    test "respects explicit python_executable config" do
      config = %{python_executable: "/usr/bin/python3.11"}
      assert {:ok, "/usr/bin/python3.11"} = System.resolve_python_executable(config)
    end

    test "validates executable exists" do
      config = %{python_executable: "/nonexistent/python"}
      assert {:error, :executable_not_found} = System.resolve_python_executable(config)
    end
  end

  describe "resolve_environment/1" do
    test "returns basic command structure" do
      assert {:ok, env} = System.resolve_environment(%{})
      assert env.command == "python3"
      assert env.args == []
      assert env.env == []
    end

    test "passes through environment variables" do
      config = %{env: [{"PYTHONPATH", "/custom/path"}]}
      assert {:ok, env} = System.resolve_environment(config)
      assert {"PYTHONPATH", "/custom/path"} in env.env
    end
  end

  describe "validate_environment/1" do
    test "validates Python is callable" do
      assert :ok = System.validate_environment(%{})
    end

    test "checks Python version meets minimum" do
      config = %{minimum_version: "3.11"}
      assert :ok = System.validate_environment(config)
    end

    test "fails if Python too old" do
      config = %{minimum_version: "3.20"}
      assert {:error, :version_too_old} = System.validate_environment(config)
    end
  end
end
```

### 2. Venv Tests (test/python_environment/venv_test.exs)

```elixir
defmodule Snakepit.PythonEnvironment.VenvTest do
  use ExUnit.Case, async: true
  alias Snakepit.PythonEnvironment.Venv

  setup do
    # Create temp directory with mock venv structure
    tmp_dir = System.tmp_dir!() |> Path.join("snakepit_test_#{:rand.uniform(10000)}")
    File.mkdir_p!(tmp_dir)
    
    venv_dir = Path.join(tmp_dir, ".venv")
    File.mkdir_p!(Path.join([venv_dir, "bin"]))
    
    # Create fake python executable
    python_path = Path.join([venv_dir, "bin", "python"])
    File.write!(python_path, "#!/bin/bash\necho 'Python 3.11.0'")
    File.chmod!(python_path, 0o755)
    
    on_exit(fn -> File.rm_rf!(tmp_dir) end)
    
    %{tmp_dir: tmp_dir, venv_dir: venv_dir, python_path: python_path}
  end

  describe "detect_venv/1" do
    test "finds .venv in project directory", %{tmp_dir: tmp_dir} do
      assert {:ok, venv_path} = Venv.detect_venv(tmp_dir)
      assert String.ends_with?(venv_path, ".venv")
    end

    test "finds venv/ directory if .venv missing", %{tmp_dir: tmp_dir} do
      venv_dir = Path.join(tmp_dir, "venv")
      File.mkdir_p!(Path.join([venv_dir, "bin"]))
      
      assert {:ok, venv_path} = Venv.detect_venv(tmp_dir)
      assert String.ends_with?(venv_path, "venv")
    end

    test "returns error if no venv found" do
      tmp = System.tmp_dir!()
      assert {:error, :venv_not_found} = Venv.detect_venv(tmp)
    end
  end

  describe "resolve_python_executable/1" do
    test "uses venv python", %{tmp_dir: tmp_dir, python_path: python_path} do
      config = %{project_dir: tmp_dir}
      assert {:ok, ^python_path} = Venv.resolve_python_executable(config)
    end

    test "respects explicit venv_path", %{tmp_dir: tmp_dir} do
      custom_venv = Path.join(tmp_dir, "custom_env")
      File.mkdir_p!(Path.join([custom_venv, "bin"]))
      
      python = Path.join([custom_venv, "bin", "python"])
      File.write!(python, "")
      File.chmod!(python, 0o755)
      
      config = %{venv_path: custom_venv}
      assert {:ok, ^python} = Venv.resolve_python_executable(config)
    end

    test "handles Windows paths (Scripts/python.exe)", %{tmp_dir: tmp_dir} do
      venv_dir = Path.join(tmp_dir, ".venv")
      File.mkdir_p!(Path.join([venv_dir, "Scripts"]))
      
      python = Path.join([venv_dir, "Scripts", "python.exe"])
      File.write!(python, "")
      
      config = %{project_dir: tmp_dir, platform: :windows}
      assert {:ok, ^python} = Venv.resolve_python_executable(config)
    end
  end

  describe "validate_environment/1" do
    test "checks venv is activated properly", %{tmp_dir: tmp_dir} do
      config = %{project_dir: tmp_dir}
      assert :ok = Venv.validate_environment(config)
    end

    test "detects broken venv" do
      tmp = System.tmp_dir!()
      broken_venv = Path.join(tmp, "broken_venv")
      File.mkdir_p!(broken_venv)
      
      config = %{venv_path: broken_venv}
      assert {:error, :invalid_venv} = Venv.validate_environment(config)
    end
  end
end
```

### 3. UV Tests (test/python_environment/uv_test.exs)

```elixir
defmodule Snakepit.PythonEnvironment.UVTest do
  use ExUnit.Case, async: true
  alias Snakepit.PythonEnvironment.UV

  setup do
    tmp_dir = System.tmp_dir!() |> Path.join("uv_test_#{:rand.uniform(10000)}")
    File.mkdir_p!(tmp_dir)
    
    # Create mock UV project
    File.write!(Path.join(tmp_dir, "uv.lock"), "# UV lock file\n")
    File.write!(Path.join(tmp_dir, "pyproject.toml"), """
    [project]
    name = "test-project"
    version = "0.1.0"
    requires-python = ">=3.11"
    """)
    
    on_exit(fn -> File.rm_rf!(tmp_dir) end)
    %{tmp_dir: tmp_dir}
  end

  describe "detect_uv_project/1" do
    test "finds uv.lock in project", %{tmp_dir: tmp_dir} do
      assert :ok = UV.detect_uv_project(tmp_dir)
    end

    test "returns error if no uv.lock" do
      tmp = System.tmp_dir!()
      assert {:error, :not_uv_project} = UV.detect_uv_project(tmp)
    end
  end

  describe "resolve_python_executable/1" do
    test "returns uv command", %{tmp_dir: tmp_dir} do
      config = %{project_dir: tmp_dir}
      assert {:ok, "uv"} = UV.resolve_python_executable(config)
    end
  end

  describe "resolve_environment/1" do
    test "constructs uv run python command", %{tmp_dir: tmp_dir} do
      config = %{project_dir: tmp_dir}
      assert {:ok, env} = UV.resolve_environment(config)
      
      assert env.command == "uv"
      assert env.args == ["run", "python"]
      assert env.cwd == tmp_dir
    end

    test "supports uv sync before execution", %{tmp_dir: tmp_dir} do
      config = %{project_dir: tmp_dir, uv_sync: true}
      assert {:ok, env} = UV.resolve_environment(config)
      
      # Should include sync step in metadata
      assert env.pre_start_commands == ["uv sync"]
    end

    test "respects UV environment variables", %{tmp_dir: tmp_dir} do
      config = %{
        project_dir: tmp_dir,
        env: [{"UV_PROJECT_ENVIRONMENT", "production"}]
      }
      
      assert {:ok, env} = UV.resolve_environment(config)
      assert {"UV_PROJECT_ENVIRONMENT", "production"} in env.env
    end
  end

  describe "validate_environment/1" do
    @tag :requires_uv
    test "checks uv is installed" do
      case System.cmd("which", ["uv"], stderr_to_stdout: true) do
        {_, 0} ->
          assert :ok = UV.validate_environment(%{})
        _ ->
          assert {:error, :uv_not_installed} = UV.validate_environment(%{})
      end
    end

    test "validates uv version meets minimum", %{tmp_dir: tmp_dir} do
      config = %{project_dir: tmp_dir, minimum_uv_version: "0.1.0"}
      # Will skip if uv not installed
      case UV.validate_environment(config) do
        :ok -> assert true
        {:error, :uv_not_installed} -> assert true
        other -> flunk("Unexpected result: #{inspect(other)}")
      end
    end
  end
end
```

### 4. Detector Tests (test/python_environment/detector_test.exs)

```elixir
defmodule Snakepit.PythonEnvironment.DetectorTest do
  use ExUnit.Case, async: true
  alias Snakepit.PythonEnvironment.Detector

  setup do
    tmp_dir = System.tmp_dir!() |> Path.join("detector_test_#{:rand.uniform(10000)}")
    File.mkdir_p!(tmp_dir)
    on_exit(fn -> File.rm_rf!(tmp_dir) end)
    %{tmp_dir: tmp_dir}
  end

  describe "detect/1" do
    test "detects UV project first (highest priority)", %{tmp_dir: tmp_dir} do
      File.write!(Path.join(tmp_dir, "uv.lock"), "")
      File.mkdir_p!(Path.join(tmp_dir, ".venv"))  # Also has venv
      
      assert {:ok, :uv, config} = Detector.detect(tmp_dir)
      assert config.project_dir == tmp_dir
    end

    test "detects Poetry project", %{tmp_dir: tmp_dir} do
      File.write!(Path.join(tmp_dir, "poetry.lock"), "")
      File.write!(Path.join(tmp_dir, "pyproject.toml"), "[tool.poetry]")
      
      assert {:ok, :poetry, config} = Detector.detect(tmp_dir)
    end

    test "detects .venv directory", %{tmp_dir: tmp_dir} do
      venv_dir = Path.join(tmp_dir, ".venv")
      File.mkdir_p!(Path.join([venv_dir, "bin"]))
      
      assert {:ok, :venv, config} = Detector.detect(tmp_dir)
      assert config.venv_path == ".venv"
    end

    test "detects pyenv from .python-version", %{tmp_dir: tmp_dir} do
      File.write!(Path.join(tmp_dir, ".python-version"), "3.13.0\n")
      
      assert {:ok, :pyenv, config} = Detector.detect(tmp_dir)
      assert config.python_version == "3.13.0"
    end

    test "falls back to system Python", %{tmp_dir: tmp_dir} do
      # Empty directory
      assert {:ok, :system, config} = Detector.detect(tmp_dir)
      assert config == %{}
    end
  end

  describe "detect_with_priority/1" do
    test "respects custom priority order", %{tmp_dir: tmp_dir} do
      File.write!(Path.join(tmp_dir, "uv.lock"), "")
      File.mkdir_p!(Path.join(tmp_dir, ".venv"))
      
      # Force venv to be checked first
      priority = [:venv, :uv, :system]
      assert {:ok, :venv, _} = Detector.detect(tmp_dir, priority: priority)
    end
  end
end
```

---

## Integration Tests

### Test Fixtures

Create real Python environments in `test/fixtures/`:

```bash
# test/fixtures/setup.sh
#!/bin/bash
set -e

FIXTURES_DIR="$(dirname "$0")"
cd "$FIXTURES_DIR"

echo "Setting up Python environment test fixtures..."

# 1. Venv fixture
echo "Creating venv fixture..."
python3 -m venv venv_fixture
venv_fixture/bin/pip install --quiet requests numpy

# 2. UV fixture (if UV installed)
if command -v uv &> /dev/null; then
  echo "Creating UV fixture..."
  mkdir -p uv_fixture
  cd uv_fixture
  uv init --quiet
  echo 'requests = "^2.31.0"' >> pyproject.toml
  uv sync --quiet
  cd ..
fi

# 3. Docker fixture
echo "Building Docker fixture..."
docker build -t snakepit-test-python:3.13 - <<EOF
FROM python:3.13-slim
RUN pip install --no-cache-dir requests numpy grpcio protobuf
WORKDIR /app
EOF

echo "✅ Fixtures ready"
```

### Integration Test Structure

```elixir
# test/integration/python_environment_integration_test.exs
defmodule Snakepit.PythonEnvironmentIntegrationTest do
  use ExUnit.Case
  
  @moduletag :integration
  @fixtures_dir Path.join([__DIR__, "..", "fixtures"])

  setup_all do
    # Ensure fixtures exist
    setup_script = Path.join(@fixtures_dir, "setup.sh")
    
    case System.cmd("bash", [setup_script], stderr_to_stdout: true) do
      {output, 0} ->
        IO.puts("✅ Fixtures ready")
        :ok
      {output, code} ->
        IO.puts("❌ Fixture setup failed:\n#{output}")
        {:skip, "Fixtures not available"}
    end
  end

  describe "Venv environment" do
    @tag :venv
    test "starts worker with venv Python" do
      config = %{
        python_environment: :venv,
        python_config: %{
          venv_path: Path.join(@fixtures_dir, "venv_fixture")
        },
        adapter_module: Snakepit.Adapters.GRPCPython
      }

      assert {:ok, worker_pid} = start_test_worker(config)
      
      # Verify Python is from venv
      assert {:ok, result} = execute_on_worker(worker_pid, "check_python_path", %{})
      assert result.python_path =~ "venv_fixture"
      
      stop_worker(worker_pid)
    end

    @tag :venv
    test "imports packages from venv" do
      config = %{
        python_environment: :venv,
        python_config: %{venv_path: Path.join(@fixtures_dir, "venv_fixture")}
      }

      {:ok, worker_pid} = start_test_worker(config)
      
      # Try importing venv-specific package
      assert {:ok, _} = execute_on_worker(worker_pid, "import_check", %{
        package: "requests"
      })
      
      stop_worker(worker_pid)
    end
  end

  describe "UV environment" do
    @tag :uv
    @tag :requires_uv
    test "starts worker with UV python" do
      config = %{
        python_environment: :uv,
        python_config: %{
          project_dir: Path.join(@fixtures_dir, "uv_fixture")
        }
      }

      assert {:ok, worker_pid} = start_test_worker(config)
      
      # Verify running under UV
      assert {:ok, result} = execute_on_worker(worker_pid, "check_environment", %{})
      assert result.uv_managed == true
      
      stop_worker(worker_pid)
    end

    @tag :uv
    @tag :requires_uv
    test "UV auto-syncs dependencies on startup" do
      config = %{
        python_environment: :uv,
        python_config: %{
          project_dir: Path.join(@fixtures_dir, "uv_fixture"),
          uv_sync: true
        }
      }

      # Should succeed even if environment not synced
      assert {:ok, worker_pid} = start_test_worker(config)
      stop_worker(worker_pid)
    end
  end

  describe "Docker environment" do
    @tag :docker
    @tag :requires_docker
    test "starts worker in Docker container" do
      # Ensure container is running
      container_name = "snakepit-test-#{:rand.uniform(10000)}"
      
      {_, 0} = System.cmd("docker", [
        "run", "-d", "--name", container_name,
        "--rm", "snakepit-test-python:3.13",
        "sleep", "300"
      ])
      
      on_exit(fn -> System.cmd("docker", ["stop", container_name]) end)

      config = %{
        python_environment: :docker,
        python_config: %{
          container_name: container_name
        }
      }

      assert {:ok, worker_pid} = start_test_worker(config)
      
      # Verify Python is inside container
      assert {:ok, result} = execute_on_worker(worker_pid, "hostname", %{})
      assert result.hostname == container_name
      
      stop_worker(worker_pid)
    end

    @tag :docker
    @tag :requires_docker
    test "handles container not running" do
      config = %{
        python_environment: :docker,
        python_config: %{
          container_name: "nonexistent-container"
        }
      }

      assert {:error, :container_not_running} = start_test_worker(config)
    end
  end

  describe "Auto-detection" do
    @tag :auto_detect
    test "auto-detects venv and uses it" do
      config = %{
        python_environment: :auto,
        python_config: %{
          project_dir: @fixtures_dir  # Has venv_fixture/
        }
      }

      assert {:ok, worker_pid} = start_test_worker(config)
      
      # Should have auto-detected and used venv
      assert {:ok, result} = execute_on_worker(worker_pid, "check_python_path", %{})
      assert result.python_path =~ "venv_fixture"
      
      stop_worker(worker_pid)
    end
  end

  # Test helpers
  defp start_test_worker(config) do
    Snakepit.Pool.WorkerSupervisor.start_worker(
      "test-worker-#{:rand.uniform(10000)}",
      Snakepit.GRPCWorker,
      config.adapter_module,
      :test_pool,
      Keyword.new(config)
    )
  end

  defp execute_on_worker(worker_pid, command, args) do
    Snakepit.GRPCWorker.execute(worker_pid, command, args, 5_000)
  end

  defp stop_worker(worker_pid) do
    GenServer.stop(worker_pid, :normal)
  end
end
```

---

## End-to-End Tests

### E2E Test Setup

```elixir
# test/e2e/full_stack_test.exs
defmodule Snakepit.E2E.FullStackTest do
  use ExUnit.Case
  
  @moduletag :e2e
  @moduletag timeout: 120_000  # 2 minutes

  setup_all do
    # Start full application
    {:ok, _} = Application.ensure_all_started(:snakepit)
    :ok
  end

  describe "Production scenario: UV + Thread profile" do
    @tag :production
    test "handles 100 concurrent requests with UV environment" do
      # Configure pool with UV
      config = %{
        name: :e2e_uv_pool,
        worker_profile: :thread,
        pool_size: 4,
        threads_per_worker: 8,
        python_environment: :uv,
        python_config: %{
          project_dir: test_fixture_path("uv_project")
        }
      }

      {:ok, pool_pid} = Snakepit.Pool.start_link(config)

      # Fire 100 concurrent requests
      tasks = for i <- 1..100 do
        Task.async(fn ->
          Snakepit.call(:e2e_uv_pool, "compute", %{value: i}, timeout: 10_000)
        end)
      end

      results = Task.await_many(tasks, 30_000)
      
      # All should succeed
      assert Enum.all?(results, fn
        {:ok, _} -> true
        _ -> false
      end)

      # Verify workers stayed healthy
      {:ok, stats} = Snakepit.Pool.stats(:e2e_uv_pool)
      assert stats.active_workers == 4

      GenServer.stop(pool_pid)
    end
  end

  describe "Production scenario: Docker + Process profile" do
    @tag :production
    @tag :docker
    test "survives worker crashes with container restarts" do
      container = "snakepit-e2e-#{:rand.uniform(10000)}"
      
      # Start container
      {_, 0} = System.cmd("docker", [
        "run", "-d", "--name", container,
        "snakepit-test-python:3.13",
        "sleep", "300"
      ])
      
      on_exit(fn -> System.cmd("docker", ["stop", container]) end)

      config = %{
        name: :e2e_docker_pool,
        worker_profile: :process,
        pool_size: 3,
        python_environment: :docker,
        python_config: %{container_name: container}
      }

      {:ok, pool_pid} = Snakepit.Pool.start_link(config)

      # Crash a worker
      {:ok, workers} = Snakepit.Pool.list_workers(:e2e_docker_pool)
      [worker | _] = workers
      Process.exit(worker.pid, :kill)

      # Wait for supervisor to restart
      Process.sleep(1000)

      # Should still be healthy
      {:ok, stats} = Snakepit.Pool.stats(:e2e_docker_pool)
      assert stats.active_workers == 3

      # Should still process requests
      assert {:ok, _} = Snakepit.call(:e2e_docker_pool, "ping", %{})

      GenServer.stop(pool_pid)
    end
  end

  describe "Migration scenario: Venv to UV" do
    @tag :migration
    test "switches environment without pool restart" do
      # Start with venv
      config = %{
        name: :migration_pool,
        python_environment: :venv,
        python_config: %{venv_path: test_fixture_path("venv_fixture")}
      }

      {:ok, pool_pid} = Snakepit.Pool.start_link(config)
      
      # Verify using venv
      {:ok, result} = Snakepit.call(:migration_pool, "check_python_path", %{})
      assert result.python_path =~ "venv_fixture"

      # Update configuration to UV
      new_config = %{config | 
        python_environment: :uv,
        python_config: %{project_dir: test_fixture_path("uv_fixture")}
      }

      # Trigger reconfiguration (Phase 4 recycling)
      Snakepit.Pool.reconfigure(:migration_pool, new_config)

      # Wait for workers to recycle
      Process.sleep(2000)

      # Verify now using UV
      {:ok, result} = Snakepit.call(:migration_pool, "check_environment", %{})
      assert result.uv_managed == true

      GenServer.stop(pool_pid)
    end
  end

  defp test_fixture_path(name) do
    Path.join([__DIR__, "..", "fixtures", name])
  end
end
```

---

## CI/CD Strategy

### GitHub Actions Workflow

```yaml
# .github/workflows/python_environments.yml
name: Python Environment Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  unit-tests:
    name: Unit Tests (Fast)
    runs-on: ubuntu-latest
    strategy:
      matrix:
        elixir: ['1.15', '1.16']
        otp: ['26', '27']
    steps:
      - uses: actions/checkout@v4
      
      - uses: erlef/setup-beam@v1
        with:
          elixir-version: ${{ matrix.elixir }}
          otp-version: ${{ matrix.otp }}
      
      - name: Cache deps
        uses: actions/cache@v3
        with:
          path: |
            deps
            _build
          key: ${{ runner.os }}-mix-${{ hashFiles('**/mix.lock') }}
      
      - run: mix deps.get
      - run: mix test --exclude integration --exclude e2e
        env:
          MIX_ENV: test

  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: unit-tests
    strategy:
      matrix:
        python-version: ['3.11', '3.12', '3.13']
    steps:
      - uses: actions/checkout@v4
      
      - uses: erlef/setup-beam@v1
        with:
          elixir-version: '1.16'
          otp-version: '27'
      
      - uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
      
      - name: Install UV
        run: curl -LsSf https://astral.sh/uv/install.sh | sh
      
      - name: Setup test fixtures
        run: |
          cd test/fixtures
          bash setup.sh
      
      - run: mix deps.get
      
      - name: Run integration tests
        run: mix test --only integration
        env:
          MIX_ENV: test
          PYTHON_VERSION: ${{ matrix.python-version }}

  docker-tests:
    name: Docker Environment Tests
    runs-on: ubuntu-latest
    needs: unit-tests
    services:
      docker:
        image: docker:dind
    steps:
      - uses: actions/checkout@v4
      
      - uses: erlef/setup-beam@v1
        with:
          elixir-version: '1.16'
          otp-version: '27'
