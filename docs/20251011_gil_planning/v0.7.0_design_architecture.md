# v0.7.0: Python Environment Management - Design & Architecture

**Status:** Design Phase
**Version:** 0.7.0
**Date:** 2025-10-11
**Author:** Snakepit Team

---

## Executive Summary

v0.7.0 introduces a **Python Environment Abstraction Layer** that eliminates the #1 friction point for Snakepit adoption: "How do I get my Python environment to work?"

**Core Philosophy:**
- **Simple for users** - Declarative configuration with intelligent auto-detection
- **Flexible for developers** - Behavior-based plugin system
- **Production-ready** - Docker/container native support
- **Zero breaking changes** - Existing configs continue to work

**Design Pattern:**
Follow the proven `WorkerProfile` behavior pattern from v0.6.0, applying the same elegant abstraction to Python environment resolution.

---

## Design Principles

### 1. **Behavior-Based Abstraction**

Mirror the successful `WorkerProfile` architecture:

```elixir
# WorkerProfile (v0.6.0 proven pattern)
@behaviour Snakepit.WorkerProfile
- start_worker/1
- stop_worker/1
- execute_request/3
- get_capacity/1

# PythonEnvironment (v0.7.0 new pattern)
@behaviour Snakepit.PythonEnvironment
- resolve_executable/1
- resolve_environment/1
- validate_environment/1
- get_metadata/1
```

### 2. **User Experience Hierarchy**

```
1. Just Works™        → Auto-detection (most users)
2. Simple Config      → :uv, :venv, :docker (power users)
3. Full Control       → Custom modules (framework developers)
```

### 3. **Integration Points**

Environment resolution happens at **worker initialization time** in `GRPCWorker.init/1`:

```elixir
# Current (v0.6.0)
executable = adapter.executable_path()

# Future (v0.7.0)
{:ok, executable, env_config} =
  PythonEnvironment.resolve(pool_config)
```

---

## Architecture Overview

### High-Level Flow

```
User Config
    ↓
PythonEnvironment.Resolver
    ↓
Environment Detection/Selection
    ↓
Validation & Metadata Collection
    ↓
GRPCWorker Initialization
    ↓
Python Process Spawned with Correct Env
```

### Component Diagram

```
┌─────────────────────────────────────────────┐
│          User Configuration                 │
│  (config.exs or runtime.exs)                │
└──────────────────┬──────────────────────────┘
                   ↓
┌─────────────────────────────────────────────┐
│     Snakepit.PythonEnvironment              │
│     - Resolver (orchestrator)               │
│     - Detector (auto-detection)             │
│     - Validator (pre-flight checks)         │
└──────────────────┬──────────────────────────┘
                   ↓
         ┌─────────┴─────────┐
         ↓                   ↓
┌─────────────────┐  ┌──────────────────┐
│ Built-in Envs   │  │ Custom Envs      │
│ - System        │  │ - User-defined   │
│ - UV            │  │ - Custom Module  │
│ - Venv          │  └──────────────────┘
│ - Pyenv         │
│ - Poetry        │
│ - Conda         │
│ - Docker        │
└────────┬────────┘
         ↓
┌─────────────────────────────────────────────┐
│        GRPCWorker.init/1                    │
│  Uses resolved config to spawn Python      │
└─────────────────────────────────────────────┘
```

---

## Core Behavior: `Snakepit.PythonEnvironment`

### Module Definition

```elixir
defmodule Snakepit.PythonEnvironment do
  @moduledoc """
  Behavior for Python environment resolution.

  Snakepit v0.7.0 supports multiple Python environment managers:
  - `:system` - System Python (default, v0.6.0 behavior)
  - `:uv` - Modern fast package manager
  - `:venv` - Standard virtualenv
  - `:pyenv` - Python version manager
  - `:poetry` - Python packaging and dependency management
  - `:conda` - Data science environment manager
  - `:docker` - Containerized Python
  - Custom module - User-defined environments

  ## Usage

      # Auto-detection (recommended)
      config :snakepit,
        pools: [
          %{name: :default, python_environment: :auto}
        ]

      # Explicit environment
      config :snakepit,
        pools: [
          %{
            name: :ml_pool,
            python_environment: :uv,
            python_config: %{project_dir: "/app"}
          }
        ]

      # Custom implementation
      config :snakepit,
        pools: [
          %{
            name: :custom,
            python_environment: MyApp.CustomPythonEnv
          }
        ]
  """

  @type config :: map()
  @type env_config :: %{
    command: String.t(),
    args: [String.t()],
    env: [{String.t(), String.t()}],
    cwd: String.t() | nil,
    metadata: map()
  }

  @doc """
  Resolve the Python executable path.

  Returns the path or command to execute Python.

  ## Examples

      # System Python
      {:ok, "/usr/bin/python3"}

      # UV
      {:ok, "uv"}  # Will execute as: uv run python

      # Venv
      {:ok, "/app/.venv/bin/python"}

      # Docker
      {:ok, "docker"}  # Will execute as: docker exec container python
  """
  @callback resolve_executable(config) ::
    {:ok, String.t()} | {:error, term()}

  @doc """
  Resolve the complete environment configuration.

  Returns all information needed to spawn the Python process.

  ## Examples

      {:ok, %{
        command: "uv",
        args: ["run", "python"],
        env: [{"UV_PROJECT_ENVIRONMENT", "production"}],
        cwd: "/app/ml_service",
        metadata: %{
          python_version: "3.13.0",
          environment_type: :uv,
          package_manager: "uv"
        }
      }}
  """
  @callback resolve_environment(config) ::
    {:ok, env_config()} | {:error, term()}

  @doc """
  Validate that the environment is properly configured.

  Performs pre-flight checks before worker initialization.

  ## Examples

      # Success
      :ok

      # Missing virtualenv
      {:error, :venv_not_found, "/app/.venv"}

      # Docker container not running
      {:error, :container_not_running, "python-worker-1"}

      # Python version mismatch
      {:error, :version_mismatch, %{
        expected: "3.13+",
        actual: "3.11.5"
      }}
  """
  @callback validate_environment(config) ::
    :ok | {:error, term(), details :: term()}

  @doc """
  Get environment metadata.

  Returns diagnostic information about the Python environment.

  ## Examples

      {:ok, %{
        python_version: "3.13.0",
        environment_type: :uv,
        environment_path: "/home/user/.local/share/uv",
        packages_installed: 47,
        free_threading_enabled: true,
        gil_disabled: true
      }}
  """
  @callback get_metadata(config) ::
    {:ok, map()} | {:error, term()}

  @optional_callbacks [get_metadata: 1]
end
```

---

## Built-In Environment Implementations

### 1. System Python (Default, Backward Compatible)

```elixir
defmodule Snakepit.PythonEnvironment.System do
  @behaviour Snakepit.PythonEnvironment
  @moduledoc """
  System Python environment (default).

  Uses Python from system PATH. This is the v0.6.0 default behavior.
  """

  @impl true
  def resolve_executable(config) do
    explicit = Map.get(config, :python_executable)
    env_var = System.get_env("SNAKEPIT_PYTHON")
    system = System.find_executable("python3") ||
             System.find_executable("python")

    case explicit || env_var || system do
      nil -> {:error, :python_not_found}
      path -> {:ok, path}
    end
  end

  @impl true
  def resolve_environment(config) do
    with {:ok, python} <- resolve_executable(config) do
      {:ok, %{
        command: python,
        args: [],
        env: [],
        cwd: nil,
        metadata: %{environment_type: :system}
      }}
    end
  end

  @impl true
  def validate_environment(config) do
    with {:ok, python} <- resolve_executable(config),
         true <- File.exists?(python) ||
                 !is_nil(System.find_executable(python)) do
      :ok
    else
      false -> {:error, :python_not_found, config}
      error -> error
    end
  end

  @impl true
  def get_metadata(config) do
    with {:ok, python} <- resolve_executable(config) do
      version = get_python_version(python)
      gil_disabled = check_gil_status(python)

      {:ok, %{
        python_path: python,
        python_version: version,
        environment_type: :system,
        free_threading_enabled: gil_disabled
      }}
    end
  end

  # Private helpers
  defp get_python_version(python) do
    case System.cmd(python, ["--version"]) do
      {output, 0} ->
        output
        |> String.trim()
        |> String.replace("Python ", "")
      _ -> "unknown"
    end
  end

  defp check_gil_status(python) do
    # Check if Python 3.13+ with GIL disabled
    case System.cmd(python, ["-c", "import sys; print(getattr(sys.flags, 'gil', -1))"]) do
      {"0\n", 0} -> true  # GIL disabled
      _ -> false
    end
  end
end
```

### 2. UV Environment (Modern Standard)

```elixir
defmodule Snakepit.PythonEnvironment.UV do
  @behaviour Snakepit.PythonEnvironment
  @moduledoc """
  UV Python environment manager.

  UV is the modern, fast Python package manager.

  ## Detection

  Automatically detected if `uv.lock` exists in project directory.

  ## Configuration

      %{
        python_environment: :uv,
        python_config: %{
          project_dir: "/app/ml_service",  # Required
          python_version: "3.13",          # Optional
          uv_environment: "production"     # Optional
        }
      }
  """

  @impl true
  def resolve_executable(_config) do
    case System.find_executable("uv") do
      nil -> {:error, :uv_not_found}
      path -> {:ok, path}
    end
  end

  @impl true
  def resolve_environment(config) do
    with {:ok, uv} <- resolve_executable(config) do
      project_dir = Map.get(config, :project_dir, File.cwd!())
      python_version = Map.get(config, :python_version)
      uv_env = Map.get(config, :uv_environment, "production")

      args = ["run", "python"]
      args = if python_version,
        do: ["--python", python_version | args],
        else: args

      {:ok, %{
        command: uv,
        args: args,
        env: [{"UV_PROJECT_ENVIRONMENT", uv_env}],
        cwd: project_dir,
        metadata: %{
          environment_type: :uv,
          project_dir: project_dir,
          python_version: python_version
        }
      }}
    end
  end

  @impl true
  def validate_environment(config) do
    project_dir = Map.get(config, :project_dir, File.cwd!())
    uv_lock = Path.join(project_dir, "uv.lock")

    cond do
      !File.exists?(project_dir) ->
        {:error, :project_dir_not_found, project_dir}

      !File.exists?(uv_lock) ->
        {:error, :uv_lock_not_found, uv_lock}

      is_nil(System.find_executable("uv")) ->
        {:error, :uv_not_installed, nil}

      true -> :ok
    end
  end

  @impl true
  def get_metadata(config) do
    project_dir = Map.get(config, :project_dir, File.cwd!())

    # Get UV environment info
    case System.cmd("uv", ["run", "python", "--version"],
                    cd: project_dir) do
      {output, 0} ->
        version = String.trim(output) |> String.replace("Python ", "")

        {:ok, %{
          environment_type: :uv,
          project_dir: project_dir,
          python_version: version,
          uv_lock: Path.join(project_dir, "uv.lock"),
          free_threading_enabled: String.starts_with?(version, "3.13")
        }}

      _ -> {:error, :metadata_collection_failed}
    end
  end
end
```

### 3. Docker Environment (Production Pattern)

```elixir
defmodule Snakepit.PythonEnvironment.Docker do
  @behaviour Snakepit.PythonEnvironment
  @moduledoc """
  Docker containerized Python environment.

  Executes Python inside a Docker container.

  ## Configuration

      %{
        python_environment: :docker,
        python_config: %{
          container_name: "python-worker-1",  # Required
          image: "myapp/python:3.13-slim",    # Optional
          python_path: "/usr/local/bin/python3" # Optional
        }
      }
  """

  @impl true
  def resolve_executable(_config) do
    case System.find_executable("docker") do
      nil -> {:error, :docker_not_found}
      path -> {:ok, path}
    end
  end

  @impl true
  def resolve_environment(config) do
    with {:ok, docker} <- resolve_executable(config) do
      container = Map.fetch!(config, :container_name)
      python_path = Map.get(config, :python_path, "python3")

      {:ok, %{
        command: docker,
        args: ["exec", "-i", container, python_path],
        env: [],
        cwd: nil,
        metadata: %{
          environment_type: :docker,
          container_name: container,
          python_path: python_path
        }
      }}
    end
  end

  @impl true
  def validate_environment(config) do
    container = Map.fetch!(config, :container_name)

    # Check if container exists and is running
    case System.cmd("docker", ["inspect", "-f", "{{.State.Running}}",
                               container]) do
      {"true\n", 0} -> :ok
      {"false\n", 0} -> {:error, :container_not_running, container}
      _ -> {:error, :container_not_found, container}
    end
  end

  @impl true
  def get_metadata(config) do
    container = Map.fetch!(config, :container_name)
    python_path = Map.get(config, :python_path, "python3")

    case System.cmd("docker", ["exec", container, python_path,
                               "--version"]) do
      {output, 0} ->
        version = String.trim(output) |> String.replace("Python ", "")

        {:ok, %{
          environment_type: :docker,
          container_name: container,
          python_version: version,
          python_path: python_path
        }}

      _ -> {:error, :metadata_collection_failed}
    end
  end
end
```

### 4. Venv Environment (Traditional)

```elixir
defmodule Snakepit.PythonEnvironment.Venv do
  @behaviour Snakepit.PythonEnvironment
  @moduledoc """
  Standard Python virtualenv environment.

  ## Detection

  Automatically detected if `.venv/` or `venv/` exists.

  ## Configuration

      %{
        python_environment: :venv,
        python_config: %{
          venv_path: ".venv"  # Relative or absolute path
        }
      }
  """

  @impl true
  def resolve_executable(config) do
    venv_path = Map.get(config, :venv_path, ".venv")
    python_bin = Path.join([venv_path, "bin", "python3"])

    cond do
      File.exists?(python_bin) -> {:ok, Path.expand(python_bin)}
      File.exists?(Path.expand(python_bin)) ->
        {:ok, Path.expand(python_bin)}
      true -> {:error, :venv_not_found}
    end
  end

  @impl true
  def resolve_environment(config) do
    with {:ok, python} <- resolve_executable(config) do
      venv_path = Map.get(config, :venv_path, ".venv")

      {:ok, %{
        command: python,
        args: [],
        env: [{"VIRTUAL_ENV", Path.expand(venv_path)}],
        cwd: nil,
        metadata: %{
          environment_type: :venv,
          venv_path: venv_path
        }
      }}
    end
  end

  @impl true
  def validate_environment(config) do
    venv_path = Map.get(config, :venv_path, ".venv")

    cond do
      !File.dir?(venv_path) ->
        {:error, :venv_not_found, venv_path}

      !File.exists?(Path.join([venv_path, "bin", "python3"])) ->
        {:error, :venv_invalid, venv_path}

      true -> :ok
    end
  end
end
```

---

## Resolver & Auto-Detection

### Resolver Module

```elixir
defmodule Snakepit.PythonEnvironment.Resolver do
  @moduledoc """
  Orchestrates Python environment resolution.

  Handles auto-detection, validation, and environment selection.
  """

  alias Snakepit.PythonEnvironment

  @doc """
  Resolve Python environment from pool configuration.

  ## Resolution Priority

  1. Explicit `python_environment` config
  2. Auto-detection via Detector
  3. Fallback to :system
  """
  def resolve(pool_config) do
    env_type = Map.get(pool_config, :python_environment, :auto)
    python_config = Map.get(pool_config, :python_config, %{})

    case env_type do
      :auto -> auto_resolve(python_config)
      :system -> resolve_with(PythonEnvironment.System, python_config)
      :uv -> resolve_with(PythonEnvironment.UV, python_config)
      :venv -> resolve_with(PythonEnvironment.Venv, python_config)
      :pyenv -> resolve_with(PythonEnvironment.Pyenv, python_config)
      :poetry -> resolve_with(PythonEnvironment.Poetry, python_config)
      :conda -> resolve_with(PythonEnvironment.Conda, python_config)
      :docker -> resolve_with(PythonEnvironment.Docker, python_config)
      module when is_atom(module) ->
        resolve_with(module, python_config)
      invalid ->
        {:error, {:invalid_python_environment, invalid}}
    end
  end

  defp auto_resolve(config) do
    base_dir = Map.get(config, :project_dir, File.cwd!())

    case PythonEnvironment.Detector.detect(base_dir) do
      {:ok, env_type, detected_config} ->
        merged_config = Map.merge(detected_config, config)
        resolve_with(get_module(env_type), merged_config)

      {:error, reason} ->
        # Fallback to system Python
        Logger.info("Auto-detection failed: #{inspect(reason)}, using system Python")
        resolve_with(PythonEnvironment.System, config)
    end
  end

  defp resolve_with(module, config) do
    with :ok <- module.validate_environment(config),
         {:ok, env_config} <- module.resolve_environment(config) do
      {:ok, env_config}
    else
      {:error, reason, details} ->
        {:error, {:validation_failed, module, reason, details}}

      {:error, reason} ->
        {:error, {:resolution_failed, module, reason}}
    end
  end

  defp get_module(:system), do: PythonEnvironment.System
  defp get_module(:uv), do: PythonEnvironment.UV
  defp get_module(:venv), do: PythonEnvironment.Venv
  defp get_module(:pyenv), do: PythonEnvironment.Pyenv
  defp get_module(:poetry), do: PythonEnvironment.Poetry
  defp get_module(:conda), do: PythonEnvironment.Conda
  defp get_module(:docker), do: PythonEnvironment.Docker
end
```

### Auto-Detector Module

```elixir
defmodule Snakepit.PythonEnvironment.Detector do
  @moduledoc """
  Automatically detects Python environment type.

  ## Detection Priority

  1. UV project (uv.lock present)
  2. Poetry (poetry.lock present)
  3. Venv (.venv/ or venv/ present)
  4. Pyenv (.python-version present)
  5. Conda (environment.yml present)
  6. System Python (fallback)
  """

  require Logger

  def detect(base_dir \\ File.cwd!()) do
    cond do
      File.exists?(Path.join(base_dir, "uv.lock")) ->
        Logger.debug("Detected UV environment")
        {:ok, :uv, %{project_dir: base_dir}}

      File.exists?(Path.join(base_dir, "poetry.lock")) ->
        Logger.debug("Detected Poetry environment")
        {:ok, :poetry, %{project_dir: base_dir}}

      File.exists?(Path.join(base_dir, ".venv")) ->
        Logger.debug("Detected Venv environment (.venv)")
        {:ok, :venv, %{venv_path: ".venv"}}

      File.exists?(Path.join(base_dir, "venv")) ->
        Logger.debug("Detected Venv environment (venv)")
        {:ok, :venv, %{venv_path: "venv"}}

      File.exists?(Path.join(base_dir, ".python-version")) ->
        version = File.read!(Path.join(base_dir, ".python-version"))
                  |> String.trim()
        Logger.debug("Detected Pyenv environment (#{version})")
        {:ok, :pyenv, %{python_version: version}}

      File.exists?(Path.join(base_dir, "environment.yml")) ->
        Logger.debug("Detected Conda environment")
        {:ok, :conda, %{project_dir: base_dir}}

      true ->
        Logger.debug("No specific environment detected, using system")
        {:ok, :system, %{}}
    end
  end
end
```

---

## Configuration Schema

### Pool Configuration Extension

```elixir
# Existing pool config (v0.6.0)
%{
  name: :default,
  worker_profile: :process,  # or :thread
  pool_size: 100,
  adapter_module: Snakepit.Adapters.GRPCPython
}

# NEW in v0.7.0
%{
  name: :default,
  worker_profile: :process,
  pool_size: 100,
  adapter_module: Snakepit.Adapters.GRPCPython,

  # Python environment configuration
  python_environment: :auto,  # or :uv, :venv, :docker, etc.
  python_config: %{
    # Environment-specific configuration
    project_dir: "/app",
    python_version: "3.13"
  }
}
```

### Configuration Examples

#### 1. Auto-Detection (Recommended)

```elixir
config :snakepit,
  pools: [
    %{
      name: :default,
      python_environment: :auto  # Detects UV, Poetry, Venv, etc.
    }
  ]
```

#### 2. Explicit UV Environment

```elixir
config :snakepit,
  pools: [
    %{
      name: :ml_pool,
      worker_profile: :thread,
      pool_size: 4,
      python_environment: :uv,
      python_config: %{
        project_dir: "/app/ml_service",
        python_version: "3.13",
        uv_environment: "production"
      }
    }
  ]
```

#### 3. Docker Production Setup

```elixir
config :snakepit,
  pools: [
    %{
      name: :docker_pool,
      python_environment: :docker,
      python_config: %{
        container_name: System.get_env("PYTHON_CONTAINER"),
        image: "myapp/python:3.13-slim"
      }
    }
  ]
```

#### 4. Multi-Environment Setup (Testing)

```elixir
config :snakepit,
  pools: [
    %{
      name: :py311,
      python_environment: :pyenv,
      python_config: %{python_version: "3.11"}
    },
    %{
      name: :py312,
      python_environment: :pyenv,
      python_config: %{python_version: "3.12"}
    },
    %{
      name: :py313,
      python_environment: :pyenv,
      python_config: %{python_version: "3.13"}
    }
  ]
```

#### 5. Custom Environment

```elixir
config :snakepit,
  pools: [
    %{
      name: :custom,
      python_environment: MyApp.CustomPythonEnv,
      python_config: %{
        # Custom configuration
      }
    }
  ]
```

---

## Integration with Existing Architecture

### Changes to GRPCWorker

```elixir
# In GRPCWorker.init/1 (current v0.6.0)
executable = adapter.executable_path()
script = adapter.script_path()
args = adapter.script_args() || []

# Enhanced in v0.7.0
pool_config = Keyword.get(opts, :pool_config, %{})

case PythonEnvironment.Resolver.resolve(pool_config) do
  {:ok, env_config} ->
    # Use resolved environment configuration
    executable = env_config.command
    script = adapter.script_path()

    # Merge adapter args with environment args
    base_args = adapter.script_args() || []
    args = env_config.args ++ [script | base_args]

    # Add environment variables
    port_opts = [
      :binary,
      :exit_status,
      :use_stdio,
      :stderr_to_stdout,
      {:args, args},
      {:cd, env_config.cwd || Path.dirname(script)},
      {:env, env_config.env}  # NEW: environment variables
    ]

    server_port = Port.open({:spawn_executable, executable}, port_opts)
    # ... rest of initialization

  {:error, reason} ->
    Logger.error("Failed to resolve Python environment: #{inspect(reason)}")
    {:stop, {:python_environment_error, reason}}
end
```

### Changes to Adapter

```elixir
# GRPCPython adapter - minimal changes needed
# executable_path/0 becomes deprecated but kept for backward compat

def executable_path do
  # Kept for backward compatibility
  # Will be overridden by PythonEnvironment in v0.7.0+
  System.find_executable("python3")
end
```

---

## GIL/Non-GIL Integration

### Profile + Environment Matrix

```elixir
# Process Profile + UV (I/O-bound, modern Python)
%{
  worker_profile: :process,
  python_environment: :uv,
  pool_size: 100
}

# Thread Profile + UV Python 3.13+ (CPU-bound, GIL-free)
%{
  worker_profile: :thread,
  python_environment: :uv,
  python_config: %{python_version: "3.13"},
  threads_per_worker: 16
}

# Process Profile + Docker (isolated production)
%{
  worker_profile: :process,
  python_environment: :docker,
  python_config: %{container_name: "worker"}
}

# Thread Profile + Docker Python 3.13t (GIL-free container)
%{
  worker_profile: :thread,
  python_environment: :docker,
  python_config: %{
    container_name: "python313t",
    image: "python:3.13-slim"
  },
  threads_per_worker: 16
}
```

### Validation Matrix

The resolver validates environment + profile compatibility:

```elixir
defmodule Snakepit.PythonEnvironment.Validator do
  def validate_profile_compatibility(env_config, pool_config) do
    profile = Map.get(pool_config, :worker_profile, :process)
    python_version = get_in(env_config, [:metadata, :python_version])

    case {profile, python_version} do
      {:thread, version} when version < "3.13" ->
        {:warning, :thread_profile_without_free_threading,
         "Thread profile works best with Python 3.13+ (GIL-free). " <>
         "Current version: #{version}"}

      {:thread, version} when version >= "3.13" ->
        gil_disabled = get_in(env_config, [:metadata, :free_threading_enabled])

        if gil_disabled do
          :ok
        else
          {:warning, :gil_still_enabled,
           "Python 3.13+ detected but GIL not disabled. " <>
           "Consider using python3.13t"}
        end

      _ -> :ok
    end
  end
end
```

---

## Mix Task: `mix snakepit.check_python`

### Implementation

```elixir
defmodule Mix.Tasks.Snakepit.CheckPython do
  use Mix.Task
  require Logger

  @shortdoc "Validate Python environments for all pools"

  @moduledoc """
  Validates Python environment configuration for all Snakepit pools.

  ## Usage

      mix snakepit.check_python
      mix snakepit.check_python --pool ml_pool
      mix snakepit.check_python --verbose
  """

  def run(args) do
    {opts, _, _} = OptionParser.parse(args,
      switches: [pool: :string, verbose: :boolean],
      aliases: [p: :pool, v: :verbose]
    )

    Application.ensure_all_started(:snakepit)

    case Snakepit.Config.get_pool_configs() do
      {:ok, pools} ->
        pools_to_check =
          if pool_name = opts[:pool] do
            Enum.filter(pools, &(&1.name == String.to_atom(pool_name)))
          else
            pools
          end

        IO.puts("\n🐍 Checking Python environments for #{length(pools_to_check)} pool(s)...\n")

        Enum.each(pools_to_check, &check_pool(&1, opts[:verbose]))

      {:error, reason} ->
        IO.puts("❌ Configuration error: #{inspect(reason)}")
        exit({:shutdown, 1})
    end
  end

  defp check_pool(pool_config, verbose) do
    pool_name = pool_config.name
    IO.puts("#{format_name(pool_name)}")

    case PythonEnvironment.Resolver.resolve(pool_config) do
      {:ok, env_config} ->
        IO.puts("  ✅ Environment: #{env_config.metadata.environment_type}")
        IO.puts("  📍 Command: #{env_config.command}")

        if length(env_config.args) > 0 do
          IO.puts("  🔧 Args: #{Enum.join(env_config.args, " ")}")
        end

        # Get metadata
        env_module = get_env_module(env_config.metadata.environment_type)

        case env_module.get_metadata(pool_config.python_config || %{}) do
          {:ok, metadata} ->
            IO.puts("  🐍 Python: #{metadata.python_version}")

            if Map.get(metadata, :free_threading_enabled) do
              IO.puts("  ⚡ Free-threading: Enabled")
            end

            # Check profile compatibility
            case validate_profile_compat(env_config, pool_config) do
              :ok -> :ok
              {:warning, msg} ->
                IO.puts("  ⚠️  Warning: #{msg}")
            end

            if verbose do
              IO.puts("\n  Metadata:")
              Enum.each(metadata, fn {k, v} ->
                IO.puts("    #{k}: #{inspect(v)}")
              end)
            end

          {:error, reason} ->
            IO.puts("  ⚠️  Could not collect metadata: #{inspect(reason)}")
        end

      {:error, reason} ->
        IO.puts("  ❌ Error: #{format_error(reason)}")
        IO.puts("  💡 Fix: #{suggest_fix(reason)}")
    end

    IO.puts("")
  end

  defp format_name(name), do: "Pool :#{name}"

  defp format_error({:validation_failed, _module, reason, details}) do
    "#{reason} - #{inspect(details)}"
  end

  defp format_error(reason), do: inspect(reason)

  defp suggest_fix({:validation_failed, _, :venv_not_found, path}) do
    "Create virtualenv: python3 -m venv #{path}"
  end

  defp suggest_fix({:validation_failed, _, :container_not_running, name}) do
    "Start container: docker start #{name}"
  end

  defp suggest_fix(_), do: "Check configuration"

  defp get_env_module(:system), do: PythonEnvironment.System
  defp get_env_module(:uv), do: PythonEnvironment.UV
  defp get_env_module(:venv), do: PythonEnvironment.Venv
  # ... etc
end
```

### Example Output

```
$ mix snakepit.check_python

🐍 Checking Python environments for 3 pool(s)...

Pool :ml_pool
  ✅ Environment: uv
  📍 Command: uv
  🔧 Args: run python
  🐍 Python: 3.13.0
  ⚡ Free-threading: Enabled

Pool :legacy_pool
  ✅ Environment: venv
  📍 Command: /app/.venv/bin/python3
  🐍 Python: 3.11.5
  ⚠️  Warning: Thread profile works best with Python 3.13+

Pool :docker_pool
  ❌ Error: container_not_running - python-worker-1
  💡 Fix: Start container: docker start python-worker-1
```

---

## Migration & Backward Compatibility

### Zero Breaking Changes

```elixir
# v0.6.0 configuration - continues to work unchanged
config :snakepit,
  pooling_enabled: true,
  adapter_module: Snakepit.Adapters.GRPCPython,
  pool_size: 100

# Internally converted to:
%{
  name: :default,
  worker_profile: :process,
  pool_size: 100,
  adapter_module: Snakepit.Adapters.GRPCPython,
  python_environment: :system  # Default
}
```

### Opt-In Adoption

Users can gradually adopt new features:

```elixir
# Step 1: Try auto-detection
config :snakepit,
  pools: [
    %{
      name: :default,
      python_environment: :auto
    }
  ]

# Step 2: Explicit environment
config :snakepit,
  pools: [
    %{
      name: :default,
      python_environment: :uv,
      python_config: %{project_dir: "/app"}
    }
  ]

# Step 3: Multi-pool with different environments
config :snakepit,
  pools: [
    %{name: :api, python_environment: :docker, ...},
    %{name: :batch, python_environment: :uv, ...}
  ]
```

---

## Testing Strategy

### Unit Tests

```elixir
defmodule Snakepit.PythonEnvironment.SystemTest do
  use ExUnit.Case

  describe "resolve_executable/1" do
    test "finds system python3" do
      assert {:ok, path} = System.resolve_executable(%{})
      assert String.contains?(path, "python")
    end

    test "respects explicit config" do
      config = %{python_executable: "/custom/python"}
      assert {:ok, "/custom/python"} = System.resolve_executable(config)
    end
  end
end

defmodule Snakepit.PythonEnvironment.UVTest do
  use ExUnit.Case

  describe "validate_environment/1" do
    test "detects missing uv.lock" do
      config = %{project_dir: "/tmp/no_uv"}
      assert {:error, :uv_lock_not_found, _} = UV.validate_environment(config)
    end
  end
end
```

### Integration Tests

```elixir
defmodule Snakepit.PythonEnvironmentIntegrationTest do
  use ExUnit.Case

  test "auto-detection in UV project" do
    # Create temp UV project
    tmp = Path.join(System.tmp_dir!(), "uv_test")
    File.mkdir_p!(tmp)
    File.write!(Path.join(tmp, "uv.lock"), "")

    config = %{python_environment: :auto, python_config: %{project_dir: tmp}}

    {:ok, pools} = Snakepit.Config.validate_pool_config(%{name: :test, python_config: config})
    {:ok, env_config} = PythonEnvironment.Resolver.resolve(pools)

    assert env_config.metadata.environment_type == :uv

    File.rm_rf!(tmp)
  end
end
```

---

## Performance Considerations

### Resolution Caching

Environment resolution happens once per worker at initialization:

```elixir
# Cached in worker state
state = %{
  env_config: env_config,  # Resolved once
  connection: connection,
  # ...
}

# No re-resolution on every request
```

### Minimal Overhead

```
Before (v0.6.0):
  - executable_path() -> 1 System.find_executable call

After (v0.7.0):
  - Resolver.resolve() -> 1 detection + 1 validation
  - Same order of magnitude (~1-2ms)
```

---

## Error Handling & User Experience

### Clear Error Messages

```elixir
{:error, {:validation_failed,
  Snakepit.PythonEnvironment.UV,
  :uv_lock_not_found,
  "/app/uv.lock"}}

# Formatted for user:
"""
❌ Pool :ml_pool failed to initialize
   Environment: UV
   Error: uv.lock not found
   Location: /app/uv.lock
   Fix: Ensure you're in a UV project directory or run 'uv init'
"""
```

### Startup Validation

```elixir
# Application.start validates all pools before starting
def start(_type, _args) do
  case validate_all_pools() do
    :ok -> start_supervision_tree()
    {:error, errors} ->
      print_validation_errors(errors)
      {:error, :invalid_configuration}
  end
end
```

---

## Documentation Strategy

### User-Facing Docs

1. **Quick Start Guide** - Auto-detection example
2. **Environment Guide** - Per-environment configuration
3. **Migration Guide** - v0.6.0 → v0.7.0
4. **Troubleshooting** - Common issues and fixes

### Developer Docs

1. **Behavior Reference** - `PythonEnvironment` API
2. **Custom Environments** - Writing custom implementations
3. **Architecture** - How resolution works

---

## Summary

v0.7.0 Python Environment Management:

✅ **Simple** - Auto-detection + declarative config
✅ **Flexible** - Behavior-based plugin system
✅ **Production-Ready** - Docker/container native
✅ **Zero Breaking Changes** - Full backward compatibility
✅ **GIL-Aware** - Integrates with v0.6.0 thread profile
✅ **Battle-Tested Pattern** - Mirrors `WorkerProfile` success

**Value Proposition:**
Eliminates the #1 adoption friction by making Snakepit "just work" with any Python setup, from local development to production containers.
